[{"id":0,"href":"/go-course/quickstart/","title":"Quickstart","section":"Docs","content":"Quickstart #  Installation #  To install Go, just follow the documentation in the official web page\nIs really simple to install.\nVersion Manager #  I personally like to use a version manager to easily change versions working cross projets.\nI use g, but there are a lot of others out there. Just pick the one you like more.\nPrivate Repository #  If you want to use some private repository (and probably you will), you will need to configure 2 things:\n1 - GOPRIVATE #  First, you will need to configure the env var GOPRIVATE.\nThis variable will tell to go that those hosts listed are private repositories, example:\nGOPRIVATE=bitbucket.my.domain.com  You can use multiples domains, just separate them using comma \u0026ldquo;,\u0026rdquo;\nGOPRIVATE=bitbucket.my.domain.com,bitbucket.org/my_private_repository  2 - Configure the creadentials #  Go handles its dependencies accessing directly the source code in the repositories. It uses http to download the sources.\nAs you code is in a private repository, you will need to tell go to use git to do that.\nYou can do that typing something like that:\ngit config --global url.\u0026quot;git@bitbucket.org:\u0026quot;.insteadOf \u0026quot;https://bitbucket.org/\u0026quot;  If you will use ssh, you can type:\ngit config --global url.\u0026quot;ssh://git@bitbucket.org:\u0026quot;.insteadOf \u0026quot;https://bitbucket.org/\u0026quot;  "},{"id":1,"href":"/go-course/hello-world/","title":"Hello world","section":"Docs","content":"Hello world #  First Project #  Let\u0026rsquo;s create the first project.\nCreate a folder to use as project folder.\nmkdir helloworld; cd helloworld  Then create your first file main.go and type the following code:\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello world\u0026#34;) } To run it, just type:\ngo run main.go  So let\u0026rsquo;s understand the code.\npackage #  The first line of code is the package name. The main package is the one that will contain the main method. Only this package is allowed to start a go application.\nimport #  The next lines we have the imports. We can refer a list of dependencies, just creating a list of imports inside parentheses:\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;strconv\u0026#34; ) The list should be one in each line and typed between quotation marks \u0026quot;\u0026quot;.\nAs expected, we can\u0026rsquo;t have imports with same name, so we must use an alias for some import.\nimport ( \u0026#34;fmt\u0026#34; myfmt \u0026#34;my-custom-lib/fmt\u0026#34; ) By convencion, the import names should be all in small letter not camel case\nfunc main #  To start a go app, we need a main function, that follows the contract.\nfunc main() { ... } Named \u0026ldquo;main\u0026rdquo;, no args and no returns.\n"},{"id":2,"href":"/go-course/basics/","title":"Basics","section":"Docs","content":"Basics #  So let\u0026rsquo;s create a basic addition code.\npackage main import \u0026#34;fmt\u0026#34; func addInt(x int, y int) int { return x + y } func printResult(result string) { fmt.Println(result) } func main() { a := 5 b := 3 sum := addInt(a, b) messageResult := fmt.Sprintf(\u0026#34;the sum of %d and %d is %d\u0026#34;, a, b, sum) printResult(messageResult) } Functions #  Here we created our first function. It is composed by 3 main points:\nFunction Name #  Its name:\naddInt  Function Params #  Its params:\n(x int, y int)  The params must always be between parentheses, and for params of same type, we can omit type of all but the last param.\nLike this:\nfunc exemple(x, y, z int) int { return x + y + z } And we can blend types\nfunc addPrint(x, y, z int, messageFormat string) { fmt.Printf(messageFormat, x + y + z) } Function Returns #  Its return:\nint  If the function returns something, we need to use \u0026ldquo;:\u0026rdquo; and put the type of return.\nWe can return more then one value, but we need to put it between parentheses.\nfunc example(x, y int, messageFormat string) (int, string) { sum := x + y messageFormatted := fmt.Sprintf(messageFormat, sum) return sum, messageFormatted } We can also define names for the results and assign them in the code, but if we do it for one return value, we need to put in all of them.\nfunc example(x, yint, messageFormat string) (sum int, messageFormatted string) { sum = x + y messageFormatted = fmt.Sprintf(messageFormat, sum) return } The difference is that you don\u0026rsquo;t need to init the variables of return, they are already initialized, and you don\u0026rsquo;t need to pass them in the return statement.\nVariable Initialization #  Talking about variable initialization, we have some different ways.\nWe can use var to init variables.\npackage main import \u0026#34;fmt\u0026#34; func main() { var var1 int var var2, var3 int var var4, var5 = 9, 5 var3 = 4 fmt.Println(var1) // 0  fmt.Println(var2) // 0  fmt.Println(var3) // 4  fmt.Println(var4) // 9  fmt.Println(var5) // 5 } As we can see, if we don\u0026rsquo;t pass any value, the var will be stated with default/empty value.\nWe can also init variables with already with values not using var. We can use := , but in this case, we can\u0026rsquo;t init the variable with no value assigned.\npackage main import \u0026#34;fmt\u0026#34; func main() { var1 := 3 var2, var3 := 2, 4 fmt.Println(var1) // 3  fmt.Println(var2) // 2  fmt.Println(var3) // 4 } If some variable is already created and you want to assign other value to it and create a new variable at the same time, you need to use the := notation.\npackage main import \u0026#34;fmt\u0026#34; func main() { var1 := 3 var1, var2 := functionWithTwoReturns() fmt.Println(var1) fmt.Println(var2) } Basic Types #  We have a lot of types to use:\nbool // empty value is \u0026quot;false\u0026quot; string // empty value is \u0026quot;\u0026quot; int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr // empty value is 0 byte // alias for uint8 // empty value is 0 rune // alias for int32 // represents a Unicode code point // empty value is 0 float32 float64 // empty value is 0 complex64 complex128 // empty value is 0  You can convert types just by typing T(v):\ni := 123 f := float64(i) u := uint(f)  There is also a blank identifier, _\nIs used to ignore one paramer\nvar1, _ := functionWithTwoReturns()  Constants #  The notation of constants simple:\nconst zero = 0 const one = 1 const ( ten = 10 pi = 3.14 ) There is no need to use := to init the value.\nSwitch Case #  The switch case follows that model\nfunc main() { s := \u0026#34;key\u0026#34; switch s { case \u0026#34;key\u0026#34;: println(\u0026#34;value is key\u0026#34;) case \u0026#34;wallet\u0026#34;: println(\u0026#34;value is wallet\u0026#34;) fallthrough // thill will call the case below \tcase \u0026#34;money\u0026#34;: println(\u0026#34;value is money\u0026#34;) default: println(\u0026#34;unmapped value\u0026#34;) } } If the expressions fits some case, it will execute and quit the switch.\nYou can execute thecase and the case below using the command fallthrough.\nIf the value does not fit any case, it will execute the default case.\nIf there is no default case, it will do nothing.\nYou can also create an empty switch case:\nfunc main() { myvar := 4 switch { case 1 == myvar: println(\u0026#34;value is one\u0026#34;) case myvar \u0026gt; 5: println(\u0026#34;value is more then five\u0026#34;) } Arrays/Slice #  In go, we have arrays and slices. You don\u0026rsquo;t need to worry about the differences now, so let\u0026rsquo;s pretend that they are the same.\nThe notaion is:\n[]type  Example:\n[]string // string array []int // int array  Create #  We can create a slice this ways:\nfunc main() { length := 10 s := make([]string, length) var array [10]string } In that case, we created a slice with 10 positions.\nWe can specify the total capacity of the array, and the actual length of it.\nfunc main() { capacity := 10 length := 2 s := make([]string, length, capacity) } We can also create a slice already with values.\nfunc main() { a := []int{5, 3, 4} } Manipulate #  We can manipulate the values using the index\nfunc main() { a := []int{5, 3, 4} println(a[1]) // 3  a[1] = 9 println(a[1]) // 9 } We can select only part of the arrays\nfunc main() { a := []int{5, 8, 4, 7} fmt.Println(a[0:2]) // [5 8]  b := a[2:4] fmt.Println(b) // [4 7]  fmt.Println(b[1]) // 7 } Map #  Maps as alike slices, but they does not have total capacity\nThe notaion is:\nmap[keyType]valueType  Example:\nmap[int]string // map with int key, and string value map[int]int // map with int key, and int value  Create #  We can create a map like this\nfunc main() { m := make(map[int]string) } We can also create a map already with values\nfunc main() { m := map[int]string{ 1: \u0026#34;value1\u0026#34;, 2: \u0026#34;value2\u0026#34;, } fmt.Println(m) // map[1:value1 2:value2] \tfmt.Println(m[1]) // value1 } Manipulate #  As slices, we can manipulate the map using the index\nfunc main() { m := map[int]string{ 1: \u0026#34;value1\u0026#34;, } fmt.Println(m) // map[1:value1] \tfmt.Println(m[1]) // value1  m[1] = \u0026#34;newValue\u0026#34; m[2] = \u0026#34;value\u0026#34; fmt.Println(m) // map[1:newValue 2:value] } Channel #  Channels are alike queues, they can store data, and deliver data.\nThe notaion is:\nchan type  Example:\nchan string // channel of strings chan int // channel of ints  Create #  func main() { capacity := 10 c := make(chan int, capacity) } Manipulate #  We can add or remove data from channels with a special operation\nfunc main() { capacity := 10 c := make(chan int, capacity) c \u0026lt;- 1 c \u0026lt;- 2 c \u0026lt;- 3 v1 := \u0026lt;-c v2 := \u0026lt;-c v3 := \u0026lt;-c println(v1) // 1 \tprintln(v2) // 2 \tprintln(v3) // 3 } If the channel is full, it will block the current thread until there is space to store\nfunc main() { capacity := 2 c := make(chan int, capacity) c \u0026lt;- 1 c \u0026lt;- 2 c \u0026lt;- 3 // this will block the thread execution } We can also pass a second param to receive if the channel still working\nfunc main() { capacity := 2 c := make(chan int, capacity) c \u0026lt;- 1 v, ok := \u0026lt;- c if ok { println(v) } else { println(\u0026#34;closed channel\u0026#34;) } } Loops #  Go suports only one command of loop, the for statment.\nIndexed #  We have the for statement that executes a loop\nfunc main(){ for i := 0; i \u0026lt; 5; i++ { println(i) } } Infinite #  We can create infinit loops.\nfunc main(){ i := 0 for { println(i) if i \u0026gt; 5 { break; } i++ } } To interact with loops, we can use the commands: break, continue\n break: exists the loop continue: goes to the next iteration  Iteration #  We can also iterate through maps and slices/arrays.\nYou will need to use the range command.\nArrays/slice #  func main() { list := []string{\u0026#34;val1\u0026#34;, \u0026#34;val2\u0026#34;} for i, v := range list { fmt.Printf(\u0026#34;position %d has the value %s\u0026#34;, i, v) } } Maps #  func main() { m := map[int]string{ 1: \u0026#34;value1\u0026#34;, 2: \u0026#34;value2\u0026#34;, } for k, v := range list { fmt.Printf(\u0026#34;key %d has the value %s\u0026#34;, k, v) } } Embedded functions #  In go we have some native funcs to help us to work with go.\nprint #  To print in the console, we have the basic functions\nfunc main() { print(\u0026#34;someoutput\u0026#34;) println(\u0026#34;print and break line\u0026#34;) } make #  To create arrays/slice, maps or channels, we can use the func \u0026ldquo;make\u0026rdquo;\nfunc main() { length := 4 capacity := 10 myArray := make([]int, length, capacity) myMap := make(map[string]int) myChan := make(chan int) } len #  We can check the length of channels, maps and arrays/slices using len()\nfunc main() { length := 4 capacity := 10 myArray := make([]int, length, capacity) println(len(myArray)) // 4  myMap := make(map[string]int) println(len(myMap)) // 0  capacityC := 5 myChan := make(chan int, capacityC) myChan \u0026lt;- i // add data to the channel  println(len(myChan)) // 1 } cap #  We can check the total capacity of a channel or an array/slice using cap()\nfunc main() { length := 4 capacity := 10 myArray := make([]int, length, capacity) println(cap(myArray)) // 10  capacityC := 5 myChan := make(chan int, capacityC) myChan \u0026lt;- i // add data to the channel  println(cap(myChan)) // 5 } append #  We can append data to and array/slice using append()\nAppend will expand the capacity of yout array if it does not have capacity to store the new value.\nfunc main() { myArray := make([]string, 0, 1) println(len(myArray)) // 0  println(cap(myArray)) // 1  println(\u0026#34;---\u0026#34;) myArray = append(myArray, \u0026#34;someString\u0026#34;) println(len(myArray)) // 1  println(cap(myArray)) // 1  println(\u0026#34;---\u0026#34;) myArray = append(myArray, \u0026#34;moreData\u0026#34;) println(len(myArray)) // 2  println(cap(myArray)) // 2 } defer #  Defer is command that tells go to execute that function at the end of the current function, no matter what happens, ether a return or a panic.\ntype myStr struct { Data string } func main() { defer func() { println(\u0026#34;main exited\u0026#34;) }() var str *myStr println(str.Data) } This will result in something like this:\n... main exited panic: runtime error: invalid memory address or nil pointer dereference ...  new #  The function new creates a new pointer of the type passed as param with empty value (not nil)\nfunc main() { str := new(string) println(*str) // \u0026#34;\u0026#34; } close #  The clonse function is used to close channels.\nfunc main() { c := make(chan int, 1) c \u0026lt;- 0 \u0026lt;- c close(c) } others #  All the functions are in the builtin.go file.\nYou can the all the others function in that file. Feel free to open the file and see the docs.\n"},{"id":3,"href":"/go-course/json/","title":"JSON","section":"Docs","content":"JSON #  Work With Json #  To handle json, go has a native librabry for that.\nencoding/json  It is really easy to use it.\nCheck the example below.\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) const myJson = `{ \u0026#34;name\u0026#34;: \u0026#34;my name\u0026#34;, \u0026#34;age\u0026#34;: 15, \u0026#34;alive\u0026#34;: true, \u0026#34;extras\u0026#34;: \u0026#34;extra infos\u0026#34;, \u0026#34;privateField\u0026#34;: \u0026#34;using a private field\u0026#34;, \u0026#34;omitted\u0026#34;: \u0026#34;field omitted if empty\u0026#34; }` type user struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Alive bool `json:\u0026#34;alive\u0026#34;` DateOfBirth string `json:\u0026#34;dob\u0026#34;` privateField string `json:\u0026#34;privateField\u0026#34;` Omitted string `json:\u0026#34;omitted,omitempty\u0026#34;` } func main() { var u user if err := json.Unmarshal([]byte(myJson), \u0026amp;u); err != nil { fmt.Printf(\u0026#34;failure to parse json to user: %s \\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;my user is: %+v \\n\u0026#34;, u) } u.DateOfBirth = \u0026#34;2000/01/01\u0026#34; u.privateField = \u0026#34;setting private field\u0026#34; u.Omitted = \u0026#34;\u0026#34; if bytes, err := json.Marshal(u); err != nil { fmt.Printf(\u0026#34;failure to parse user to json: %s \\n\u0026#34;, err) } else { fmt.Printf(\u0026#34;my json is: %s \\n\u0026#34;, string(bytes)) } } Running this code, we have this output:\nmy user is: {Name:my name Age:15 Alive:true DateOfBirth: privateField: Omitted:field omitted if empty} my json is: {\u0026quot;name\u0026quot;:\u0026quot;my name\u0026quot;,\u0026quot;age\u0026quot;:15,\u0026quot;alive\u0026quot;:true,\u0026quot;dob\u0026quot;:\u0026quot;2000/01/01\u0026quot;}  As we can see, we have some particular behaviours.\n The Unmarshal method receives a ponter to the object to be filled It doesn\u0026rsquo;t break if not all fields are mapped in json nether in the struct (you can change that if you want) Private fields are not mapped You can remove fields if empty using the tag \u0026ldquo;omitempty\u0026rdquo;  "},{"id":4,"href":"/go-course/gin-gonic/","title":"Gin Gonic","section":"Docs","content":"Gin Gonic #  Http server with Gin Gonic #  Go has a native library to handle http requests.\nnet/http  I personally like to use the Gin Gonic and that is what I will use here.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) type user struct { Name string `json:\u0026#34;name\u0026#34;` } func main() { engine := gin.Default() engine.Handle(http.MethodPost, \u0026#34;/user\u0026#34;, createUser) engine.Handle(http.MethodGet, \u0026#34;/user\u0026#34;, getUser) if err := engine.Run(\u0026#34;:8080\u0026#34;); err != nil { fmt.Printf(\u0026#34;error with http server: %s\u0026#34;, err) } } func createUser(c *gin.Context) { var u user if err := c.ShouldBind(\u0026amp;u); err != nil { c.String(http.StatusBadRequest, fmt.Sprintf(\u0026#34;invalid body: %s\u0026#34;, err)) } else { fmt.Printf(\u0026#34;new user: %+v \\n\u0026#34;, u) c.Status(http.StatusCreated) } } func getUser(c *gin.Context) { u := user{ Name: c.DefaultQuery(\u0026#34;name\u0026#34;, \u0026#34;default name\u0026#34;), } c.JSON(http.StatusCreated, u) } In the code above, the first line in the main code, we are creating a new instance of the gin router.\nWe are using a default router, that has a logging middleware and a default recovery middleware. You can use a gin.New() one, and configure the way you want.\nengine := gin.New()  Handling requests #  We can handle paths by doing\nengine.Handle(http.MethodPost, \u0026quot;/user\u0026quot;, createUser) engine.Handle(http.MethodGet, \u0026quot;/user\u0026quot;, getUser)  createUser and getUser are funcs that follow int func type accepcted but the framework\ntype HandlerFunc func(*Context)  Group handlers #  We can group handlers that uses the same base path\ng := engine.Group(\u0026quot;/user\u0026quot;) { g.POST(\u0026quot;\u0026quot;, createUser) g.GET(\u0026quot;\u0026quot;, getUser) }  Run the server #  To run the server, we can use a several dufferent ways. The simple way is just call the func Run().\nerr := engine.Run(\u0026quot;:8080\u0026quot;)  It receives the address to run the server, you can change the port as you want.\nThe return is an error, in case of something goes wrong.\nGetting data #  As in json package, we can parse a body into a struct using some funcs from the framework. We are receiving a lot of data into the *gin.Context param.\nIn the example, we are parsing the body request into an user struct, and if it goes wrong, it will return an error.\nerr := c.ShouldBind(\u0026amp;u)  We have a some variants of the method, check the docs to see all the trics.\nWe can also get params using to her a query param with default value\nq := c.DefaultQuery(\u0026quot;queryName\u0026quot;, \u0026quot;default value\u0026quot;)  Or just to get the value (returns empty if did not receive any value)\nq := c.Query(\u0026quot;queryName\u0026quot;)  If we have a lot of query params, we can use this and it will return all your query as a plain struct\nq := c.BindQuery(\u0026amp;q)  Responding #  To return a response of the request, we don\u0026rsquo;t have a return for the method. We use the *gin.Context to do that. (\u0026ldquo;u\u0026rdquo; is a struct)\nTo return just a status:\nc.Status(http.StatusCreated)  Return a json:\nc.JSON(http.StatusCreated, u)  Return a plain text:\nc.String(http.StatusCreated, \u0026quot;text\u0026quot;)  You can also do that manually:\n_, err := c.Writer.Write([]byte(\u0026quot;my response\u0026quot;)) c.Writer.Flush()  Middlewares #  We can use middlewares creating a gin.HandlerFunc\nfunc MyMiddleware(c *gin.Context) { fmt.Println(\u0026quot;before\u0026quot;) //calls next func c.Next() fmt.Println(\u0026quot;after\u0026quot;) }  And add it to the app, to a group or just to a specific endpoint\nengine := gin.Default() //all the endpoints engine.Use(MyMiddleware) g := engine.Group(\u0026quot;/user\u0026quot;) { //to a group g.Use(MyMiddleware) g.POST(\u0026quot;\u0026quot;, createUser) g.GET(\u0026quot;\u0026quot;, getUser) } //to only one engine.Handle(http.MethodDelete, \u0026quot;/user\u0026quot;, MyMiddleware, deleteUser) "},{"id":5,"href":"/go-course/database/","title":"Database","section":"Docs","content":"Database #  Packages #  You can access database throught the sql package:\ndatabase/sql  But there are a lot of different libs with more features like:\nhttps://github.com/jmoiron/sqlx https://github.com/go-gorm/gorm https://github.com/rocketlaunchr/dbq  Here I will teach the native lib.\nImports #  Fist, we need to add the import of the lib, and the data base driver:\nimport ( \u0026#34;database/sql\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) In this case, we are using mysql and we are giving an alias to the lib as _. It means that we need the import to be kept, but we are not calling that lib in our code, otherwise, go will clean that import because it is not beeing called.\nOpen connection #  To open a connection, we use this code:\nfunc main() { strConn = \u0026#34;user:password@tcp(127.0.0.1:3306)/mydb\u0026#34; db, err := sql.Open(\u0026#34;mysql\u0026#34;, strConn) if err != nil { log.Fatal(err) } defer db.Close() } We are using the native lib to open a connection in the mysql database.\nIt requires a connection string that contains the credentials to access.\nAlso, is important to check if we need to specify the tcp connection with the database.\nUsing locally, on docker as I use, I don\u0026rsquo;t need to specify.\nTo check if we have connection, we can ping the db.\nfunc main() { strConn := \u0026#34;user:password@tcp(127.0.0.1:3306)/mydb\u0026#34; db, err := sql.Open(\u0026#34;mysql\u0026#34;, strConn) if err != nil { panic(err) } defer db.Close() if err = db.Ping(); err != nil { println(\u0026#34;failed to ping db\u0026#34;) println(err) } } Query data #  We have usually oportunity to use 2 methods to execute, one with context and one without.\nFor now, we will use only the ones with no context to make it easier.\nSingle result #  We can query data from db using the db struct.\n... userId := 10 row, err := db.Query(\u0026#34;SELECT id, email, name FROM users WHERE id = ?\u0026#34;, userId) if err != nil { log.Fatal(err) } var u User err = row.Err() if err != nil { if err == sql.ErrNoRows { // handles not found  return u } else { panic(err) } } else { if err := rows.Scan(\u0026amp;u.Id, \u0026amp;u.Email, \u0026amp;u.Name); err != nil { panic(err) } } return u Multiple results #  To search a list of results, we can do something like that\n... rows, err := db.Query(\u0026#34;SELECT id, email, name FROM users WHERE dob = ?\u0026#34;, \u0026#34;2006-01-02\u0026#34;) if err != nil { log.Fatal(err) } defer func() { if err := rows.Close(); err != nil { println(\u0026#34;failed to close query\u0026#34;) println(err) } }() results := make([]User, 0) for rows.Next() { var u User if err := rows.Scan(\u0026amp;u.Id, \u0026amp;u.Email, \u0026amp;u.Name); err != nil { panic(err) } else { results := append(results, u) } } return results Modify data #  We can modift data using the Exec method\n... res, err := db.Exec(\u0026#34;INSERT INTO users (name, dob, email) VALUES (?, ?, ?)\u0026#34;, \u0026#34;New Name\u0026#34;, \u0026#34;2000-01-01\u0026#34;, \u0026#34;some@email.com\u0026#34;) if err != nil { panic(err) } id, err := res.LastInsertId() if err != nil { panic(err) } return id Prepared statement #  We can also build prepared statements\n... stmt, err := db.Prepare(\u0026#34;INSERT INTO users (name, dob, email) VALUES (?, ?, ?)\u0026#34;) if err != nil { panic(err) } res, err := stmt.Exec(\u0026#34;New Name 2\u0026#34;, \u0026#34;2000-01-01\u0026#34;, \u0026#34;some-other@email.com\u0026#34;) if err != nil { panic(err) } id, err := res.LastInsertId() if err != nil { panic(err) } return id Transactions #  Go also suports transactions\n... tx, err := db.Begin() .... if err != nil { tx.Rollback() } else { tx.Commit() } Handle null #  We can check if a value is null using sql.NullString\nrow := stmt.Query(...) var s sql.NullString err := rows.Scan(\u0026amp;s) if err != nil { panic(err) } if s.Valid { // there is a value there, you can set it  u.email = s.String } else { // there is no value, you can do your logic \t// NULL value \t} "},{"id":6,"href":"/go-course/goroutines/","title":"Goroutines","section":"Docs","content":"Goroutines #  Go routines are process that runs in parallel, as threads.\nFirst, we need one method to be executed in paralel.\nfunc count(n int) { for i := 0; i \u0026lt; n; i++ { fmt.Printf(\u0026#34;current value %d \\r\\n\u0026#34;, i) time.Sleep(500 * time.Millisecond) } } In our main method, we can call it.\nfunc main() { n := 5 count(n) println(\u0026#34;end\u0026#34;) } We expect this result:\ncurrent value 0 current value 1 current value 2 current value 3 current value 4 end Exiting. Start a goroutine #  To start this execution in a separated process, we just add a \u0026ldquo;go\u0026rdquo; before the method\nfunc main() { n := 5 go count(n) time.Sleep(3 * time.Second) println(\u0026#34;end\u0026#34;) } We expect the same result as before:\ncurrent value 0 current value 1 current value 2 current value 3 current value 4 end Exiting. We added a sleep in the main method because the count process is running separated from the main method, and if the main method finishes, if will stop all the process stated by it.\nSyncronizing executions #  We can controll the executions using the lib sync.\nWe will use the sync.WaitGroup.\nThe wait group works as a counter, we can increase and decrease the counter, and when it blocks the current proccess until that counter cames to zero.\nfunc main() { n := 5 wg := new(sync.WaitGroup) wg.Add(1) // add to the counter \tgo func() { defer wg.Done() // ensure that when the count method finishes, it will decrease the counter \tcount(n) }() wg.Wait() // wait until the counter cames to zero. \tprintln(\u0026#34;end\u0026#34;) } Trafic data between goroutines #  We can usually trafic data between goroutines using channels.\nFollow the example:\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { n := 5 c := make(chan int, 1) wg := new(sync.WaitGroup) wg.Add(2) go func() { defer wg.Done() consumer(c) }() go func() { defer wg.Done() producer(n, c) }() wg.Wait() println(\u0026#34;end\u0026#34;) } func producer(n int, c chan int) { for i := 0; i \u0026lt; n; i++ { c \u0026lt;- i time.Sleep(500 * time.Millisecond) } close(c) } func consumer(c chan int) { for { if i, ok := \u0026lt;-c; ok { fmt.Printf(\u0026#34;current value %d \\r\\n\u0026#34;, i) } else { break } } } "}]